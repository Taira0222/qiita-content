---
title: 【Ruby】今日書いたコードの振り返り(繰り返し)#7
tags:
  - Ruby
  - 初心者
  - each
  - 未経験エンジニア
  - 独学
private: false
updated_at: '2024-12-18T07:16:00+09:00'
id: f28241bb07985e76e1f8
organization_url_name: null
slide: false
ignorePublish: false
---
# はじめに
こんにちは！アメリカに住みながら独学でソフトウェアエンジニアを目指しているものです。
今回は「たのしいRuby」のアウトプットを兼ねて、ある問題を解いた内容を振り返り、その中で学んだことについて書きたいと思います。

## 問題の内容
与えられた整数 `n` に基づき、次のような数のパターンを繰り返し表示するプログラムを作成することが求められました。

例えば、`n = 5` の場合、次のように数字を表示します。
```ruby
1
1 2
1 2 3
1 2 3 4
1 2 3 4 5
```
`n = 3`の場合は、以下の通りです
```ruby
1
1 2
1 2 3
```

## 私の回答
最初に書いたコードでは、繰り返し処理の中で配列を毎回初期化し、数字を順番に追加してから表示する方法を取りました。
```ruby
def generate_pattern(n)
    ary = []
    n.times do |number|
        (number + 1 ).times do |i|　
            ary << i + 1
        end
        puts ary.join(" ")
        ary = [] # 出力したら初期化
    end
end

generate_pattern(5)
```
上記の出力例をみて、繰り返しの中でさらに繰り返しをしていると考えて2つ`times`メソッドをとってみようと思いました。

## このコードの問題点
* 毎回 `ary = []` を使って配列をリセットしている
配列をリセットするのは効率が悪く、ただ出力するためだけに配列を初期化しているのは冗長です。リセットする手間を省く方法を考えるべきでした。

* `times` メソッドを二重に使っている
`times` メソッドを使わなくても、 `(1..(number + 1))` のような範囲を使えば、もっとシンプルに書けるはずです。

## 改善したコード
次に、冗長な部分を改善し、よりシンプルなコードに変更しました。配列のリセットを避け、 `ary = (1..number + 1).to_a` を使って、最初から必要な数字を配列に格納するようにしました。

```ruby

def generate_pattern(n)
  n.times do |number|
    # 1からnumber+1までの範囲で繰り返し、配列に格納
    ary = (1..(number + 1)).to_a
    puts ary.join(" ")
  end
end

generate_pattern(5)
```

このコードでは、配列 ary を一度だけ作成し、その後必要な数をそのまま格納して出力する形にしています。
配列のリセットもなく、コードが簡潔になり、より効率的になりました。

## もうひとつの解答例
AIを使用して違い解答パターンを作成してもらいました。
`each` メソッドを使って、より直感的に n 回の繰り返し処理を行っています。
```ruby
# パターンを生成するメソッド
def generate_pattern(n)
  # 1からnまで繰り返し処理を行う
  (1..n).each do |i|
    # 1からiまでの数を配列として作成し、スペースで結合して表示
    puts (1..i).to_a.join(" ")
  end
end

# 実行例
generate_pattern(5)
```
このコードでは、繰り返し処理のシンプルさが際立っています。配列を作成してから `join(" ")` で結合し、表示する部分までが一貫して直感的に書かれており、非常に効率的です。


## 上記を通して学んだこと
* 冗長な初期化や重複処理を避ける
`(1..n)` や `(1..i)` のような範囲オブジェクトを使うことで、`times`メソッドを二重に使わず、スッキリと書けることを実感しました。
* `each` メソッドの有効活用
繰り返し処理には`each`メソッドが便利で、`while`や`二重times`を使わなくても簡潔に表現できる場合が多いことを再確認しました。

# まとめ
今回の問題を通じて、繰り返し処理における最適なアプローチについて学びました。最初に書いたコードには冗長な部分が多く、改善したコードを通して、より効率的でシンプルな方法にたどり着けました。今回の経験を元に、今後もコードを改善していく力を養いたいと思います。

また、今後もアウトプットに関する記事をどんどん書いていきたいと考えていますので、引き続きよろしくお願いします！
